---
alwaysApply: true
---
# Godot 4.5.1 Game Development .cursorrules

## Core Development Guidelines

- MOST IMPORTANT: Use the Node's signals for loose coupling between nodes
- Use strict typing in GDScript for better error detection and IDE support
- Implement \_ready() and other lifecycle functions with explicit super() calls
- Use @onready annotations instead of direct node references in \_ready()
- Prefer composition over inheritance where possible
- Follow Godot's node naming conventions (PascalCase for nodes, snake_case for methods)

## Code Style

- Use type hints for all variables and function parameters
- Document complex functions with docstrings
- Keep methods focused and under 30 lines when possible
- Use meaningful variable and function names
- Group related properties and methods together

## Naming Conventions

- Files: Use snake_case for all filenames (e.g., player_character.gd, main_menu.tscn)
- Classes: Use PascalCase for custom class names with class_name (e.g., PlayerCharacter)
- Variables: Use snake_case for all variables including member variables (e.g., health_points)
- Constants: Use ALL_CAPS_SNAKE_CASE for constants (e.g., MAX_HEALTH)
- Functions: Use snake_case for all functions including lifecycle functions (e.g., move_player())
- Enums: Use PascalCase for enum type names and ALL_CAPS_SNAKE_CASE for enum values
- Nodes: Use PascalCase for node names in the scene tree (e.g., PlayerCharacter, MainCamera)
- Signals: Use snake_case in past tense to name events (e.g., health_depleted, enemy_defeated)

## Scene Organization

- Keep scene tree depth minimal for better performance
- Use scene inheritance for reusable components
- Implement proper scene cleanup on queue_free()
- Use SubViewport nodes carefully due to performance impact
- Provide step-by-step instructions to create Godot scene(s) instead of providing scene source code
- All gameplay-relevant 3D nodes must include both:
  - A visible MeshInstance3D for readability/debugging
  - An appropriate CollisionShape3D/CollisionObject3D for physics and signals
  (Examples: mounts, projectiles, obstacles, floors, pickups)

## Signal Best Practices

- Use clear, contextual signal names that describe their purpose (e.g., player_health_changed)
- Utilize typed signals to improve safety and IDE assistance (e.g., signal item_collected(item_name: String))
- Connect signals in code for dynamic nodes, and in the editor for static relationships
- Avoid overusing signals - reserve them for important events, not frequent updates
- Pass only necessary data through signal arguments, avoiding entire node references when possible
- Use an autoload "EventBus" singleton for global signals that need to reach distant nodes
- Minimize signal bubbling through multiple parent nodes
- Always disconnect signals when nodes are freed to prevent memory leaks
- Document signals with comments explaining their purpose and parameters

## Resource Management

- Implement proper resource cleanup in \_exit_tree()
- Use preload() for essential resources, load() for optional ones
- Consider PackedByteArray storage impact on backwards compatibility
- Implement resource unloading for unused assets

## Performance Best Practices

- Use node groups judiciously for managing collections, and prefer direct node references for frequent, specific access to individual nodes.
- Implement object pooling for frequently spawned objects
- Use physics layers to optimize collision detection
- Prefer packed arrays (PackedVector2Array, etc.) over regular arrays

## Error Handling

- Implement graceful fallbacks for missing resources
- Use assert() for development-time error checking
- Log errors appropriately in production builds
- Handle network errors gracefully in multiplayer games

## TileMap Implementation

- TileMap node is deprecated - use multiple TileMapLayer nodes instead
- Convert existing TileMaps using the TileMap bottom panel toolbox option "Extract TileMap layers"
- Access TileMap layers through TileMapLayer nodes
- Update navigation code to use TileMapLayer.get_navigation_map()
- Store layer-specific properties on individual TileMapLayer nodes

## Designer-Centric Workflow Principles

- Prioritize practical, modular helpers: expose reusable designer APIs instead of duplicating logic across scripts or scenes.
- Keep data sources centralized: prefer registries (e.g., attribute catalogs, function catalogs) that drive dropdowns and inspector hints across the project.
- Default all designer inputs to safe values and surface them via dropdowns wherever possible to prevent typos.
- When augmenting logs, prefer actionable debug entries that highlight binding, context resolution, and generator effects without spamming errors.


## Logging Standards
- All stat deltas must be logged with actor context and names, and which functions triggered it. Use emoji tags as examples:
  - `‚ù§Ô∏è` self-health gains, `üíÄ` enemy damage, `ü•§` hydration, `üí™` stamina, `‚ú®` weapon edge, `üîã` adrenaline.
- When generator effects or numeric effects fire, emit `LoggerInstance.info` so logs show precise before/after values.
- Include mover breadcrumbs (`üìè`, `üìç`, `üéØ`, `üë£`, `üö©`) for each action start, detour, and arrival.
- After each play session, review `res://log.txt` (overwritten on each run) for warnings/errors and spawn/movement breadcrumbs before debugging in code. This is the first place to check for issues.

## Project Development Principles (Mounted Warfare)

These are project-specific rules that all contributors must follow:

- Signals over direct references:
  - Prefer Node signals and the global `EventBus` to communicate across systems.
  - Avoid hard-coded tree paths or deep `get_node()` chains for cross-system calls.
- Centralized services via `Services`:
  - Access shared systems using `Services`: `Services.logger()`, `Services.bus()`, `Services.config()`.
  - Do not use direct `/root/...` lookups outside `Services` (except where `Services` is not yet available during boot).
- Strict typing everywhere:
  - Add explicit type hints for variables, parameters, return types.
  - Do not rely on `:=` Variant inference for locals unless you annotate types.
- Composition over inheritance:
  - Keep scripts small and focused; prefer composing nodes and signals to extend behavior.
- Clear naming and method size:
  - Nodes PascalCase; functions/variables snake_case; methods ~30 lines max where practical.
- Signal connection policy:
  - Connect static relationships in the editor; connect dynamic ones in code.
  - Always disconnect signals in `_exit_tree()` for dynamically connected nodes.
- Robust, actionable logging:
  - Use `LoggerInstance` categories and levels; keep logs clear, throttled, and contextual.
  - Use emojis for stat deltas and movement breadcrumbs as per Logging Standards.
- Performance-minded defaults:
  - Keep scene trees shallow; use physics layers; pool frequently spawned objects; prefer packed arrays.

### Core Architecture (Autoloads required)

- `scripts/core/logger.gd` ‚Üí Autoload as `LoggerInstance`
- `scripts/core/event_bus.gd` ‚Üí Autoload as `EventBus`
- `scripts/core/config.gd` ‚Üí Autoload as `GameConfig`
- `scripts/core/services.gd` ‚Üí Autoload as `Services`

Names must match exactly. Gameplay scripts access these singletons via `Services` whenever possible.

### Usage Patterns (Examples)

- Get logger from Services:
  - `var logger = Services.logger()`
- Broadcast decoupled gameplay events:
  - `Services.bus().emit_ammo_changed(self, ammo_current)`
  - `Services.bus().emit_player_health_changed(mount_hp, rider_hp)`
- UI should subscribe to `EventBus` first, and fall back to direct node signals if needed.
- Always type locals explicitly:
  - `var player: Node = get_tree().get_first_node_in_group("players")`
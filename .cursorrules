# Godot 4.5.1 Game Development .cursorrules

## Core Development Guidelines

- MOST IMPORTANT: Use the Node's signals for loose coupling between nodes
- Use strict typing in GDScript for better error detection and IDE support
- Implement \_ready() and other lifecycle functions with explicit super() calls
- Use @onready annotations instead of direct node references in \_ready()
- Prefer composition over inheritance where possible
- Follow Godot's node naming conventions (PascalCase for nodes, snake_case for methods)

## Code Style

- Use type hints for all variables and function parameters
- Document complex functions with docstrings
- Keep methods focused and under 30 lines when possible
- Use meaningful variable and function names
- Group related properties and methods together

## Exported Variables

- **ALWAYS add descriptions to @export variables**: Every @export variable MUST have a documentation comment on the line immediately before it that explains its purpose, units, range, or usage. This comment appears as a tooltip in the Godot editor inspector, making it easier for designers and other developers to understand and configure the property.
  - Format: The description must be on a separate line above the @export declaration using `##` (double hash) documentation comment syntax.
  - Example:
    ```
    ## Maximum forward speed in units per second
    @export var max_speed: float = 14.0
    ```
  - Example:
    ```
    ## If true, this mount responds to player input actions (accelerate, brake, turn_left, turn_right)
    @export var is_player: bool = false
    ```

## Naming Conventions

- Files: Use snake_case for all filenames (e.g., player_character.gd, main_menu.tscn)
- Classes: Use PascalCase for custom class names with class_name (e.g., PlayerCharacter)
- Variables: Use snake_case for all variables including member variables (e.g., health_points)
- Constants: Use ALL_CAPS_SNAKE_CASE for constants (e.g., MAX_HEALTH)
- Functions: Use snake_case for all functions including lifecycle functions (e.g., move_player())
- Enums: Use PascalCase for enum type names and ALL_CAPS_SNAKE_CASE for enum values
- Nodes: Use PascalCase for node names in the scene tree (e.g., PlayerCharacter, MainCamera)
- Signals: Use snake_case in past tense to name events (e.g., health_depleted, enemy_defeated)

## Scene Organization

- Keep scene tree depth minimal for better performance
- Use scene inheritance for reusable components
- Implement proper scene cleanup on queue_free()
- Use SubViewport nodes carefully due to performance impact
- Provide step-by-step instructions to create Godot scene(s) instead of providing scene source code
- All gameplay-relevant 3D nodes must include both:
  - A visible MeshInstance3D for readability/debugging
  - An appropriate CollisionShape3D/CollisionObject3D for physics and signals
  (Examples: mounts, projectiles, obstacles, floors, pickups)

## Signal Best Practices

- Use clear, contextual signal names that describe their purpose (e.g., player_health_changed)
- Utilize typed signals to improve safety and IDE assistance (e.g., signal item_collected(item_name: String))
- Connect signals in code for dynamic nodes, and in the editor for static relationships
- Avoid overusing signals - reserve them for important events, not frequent updates
- Pass only necessary data through signal arguments, avoiding entire node references when possible
- Use an autoload "EventBus" singleton for global signals that need to reach distant nodes
- Minimize signal bubbling through multiple parent nodes
- Always disconnect signals when nodes are freed to prevent memory leaks
- Document signals with comments explaining their purpose and parameters

## Resource Management

- Implement proper resource cleanup in \_exit_tree()
- Use preload() for essential resources, load() for optional ones
- Consider PackedByteArray storage impact on backwards compatibility
- Implement resource unloading for unused assets

## Performance Best Practices

- Use node groups judiciously for managing collections, and prefer direct node references for frequent, specific access to individual nodes.
- Implement object pooling for frequently spawned objects
- Use physics layers to optimize collision detection
- Prefer packed arrays (PackedVector2Array, etc.) over regular arrays

## Error Handling

- Implement graceful fallbacks for missing resources
- Use assert() for development-time error checking
- Log errors appropriately in production builds
- Handle network errors gracefully in multiplayer games

## TileMap Implementation

- TileMap node is deprecated - use multiple TileMapLayer nodes instead
- Convert existing TileMaps using the TileMap bottom panel toolbox option "Extract TileMap layers"
- Access TileMap layers through TileMapLayer nodes
- Update navigation code to use TileMapLayer.get_navigation_map()
- Store layer-specific properties on individual TileMapLayer nodes

## Designer-Centric Workflow Principles

- Prioritize practical, modular helpers: expose reusable designer APIs instead of duplicating logic across scripts or scenes.
- Keep data sources centralized: prefer registries (e.g., attribute catalogs, function catalogs) that drive dropdowns and inspector hints across the project.
- Default all designer inputs to safe values and surface them via dropdowns wherever possible to prevent typos.
- When augmenting logs, prefer actionable debug entries that highlight binding, context resolution, and generator effects without spamming errors.


## Logging Standards
- All stat deltas must be logged with actor context and names, and which functions triggered it. Use emoji tags as examples:
  - `‚ù§Ô∏è` self-health gains, `üíÄ` enemy damage, `ü•§` hydration, `üí™` stamina, `‚ú®` weapon edge, `üîã` adrenaline.
- When generator effects or numeric effects fire, emit `LoggerInstance.info` so logs show precise before/after values.
- Include mover breadcrumbs (`üìè`, `üìç`, `üéØ`, `üë£`, `üö©`) for each action start, detour, and arrival.
- After each play session, review `res://log.txt` (overwritten on each run) for warnings/errors and spawn/movement breadcrumbs before debugging in code. This is the first place to check for issues.
- Verification-first instrumentation: For every new feature/change, add lightweight, useful debug to confirm it behaves as intended even when no errors are thrown. Prefer:
  - Contextual `LoggerInstance` entries (category, node name/id, key params/outputs)
  - Temporary on-screen diagnostics (HUD labels, 3D labels) when visual confirmation helps
  - Assertions for invariants that must hold during development
  - Throttle or gate verbose logs via `GameConfig.enable_throttled_debug` and categories
  - Remove or reduce noisy logs before shipping while keeping core breadcrumbs

## Project Development Principles 

- Signals over direct references:
  - Prefer Node signals to communicate across systems.
  - Avoid hard-coded tree paths or deep `get_node()` chains for cross-system calls.
- Strict typing everywhere:
  - Add explicit type hints for variables, parameters, return types.
  - Do not rely on `:=` Variant inference for locals unless you annotate types.
- Composition over inheritance:
  - Keep scripts small and focused; prefer composing nodes and signals to extend behavior.
- Clear naming and method size:
  - Nodes PascalCase; functions/variables snake_case; methods ~30 lines max where practical.
- Signal connection policy:
  - Connect static relationships in the editor; connect dynamic ones in code.
  - Always disconnect signals in `_exit_tree()` for dynamically connected nodes.
- Robust, actionable logging:
  - Use `LoggerInstance` categories and levels; keep logs clear, throttled, and contextual.
  - Use emojis for stat deltas and movement breadcrumbs as per Logging Standards.
- Performance-minded defaults:
  - Keep scene trees shallow; use physics layers; pool frequently spawned objects; prefer packed arrays.

